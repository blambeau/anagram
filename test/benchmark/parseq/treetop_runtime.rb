module Treetop
  module Runtime
    
    #
    # Error thrown by a CompiledParser when parsing fails.
    #
    class ParseError < StandardError
      
      # Creates a ParseError instance based on a specific parser.
      def initialize(parser)
        super(parser.failure_reason)
      end
      
    end

  end
end
module Treetop
  module Runtime
    
    #
    # Parent class of parsers generated by Treetop.
    #
    # Parsers generated by Treetop extend this class, which provides the parse
    # method as well as some tools for handling parsing failures. Typical usage
    # is as follows:
    #
    #   # a parser you have generated
    #   parser = MyGrammarParser.new     # extends CompiledParser
    #   
    #   # parsing text
    #   parse_tree = parser.parse("the text to parse")
    #
    #   # handling failures
    #   if parse_tree.nil? 
    #     puts parser.failure_reason
    #   end
    #
    class CompiledParser
      include Treetop::Runtime
      
      # Input text being parsed
      attr_reader :input
      
      # Offset in input where parsing will take place
      attr_reader :index
      
      # Array of TerminalParseFailure instances
      attr_reader :terminal_failures
      
      # Maximal offset in _input_ where parse failures have occured.
      attr_reader :max_terminal_failure_index
      
      # Name of the grammar root rule (the first one in the grammar 
      # definition by default)
      attr_writer :root
      
      # Does the parser have to consume all input to consider a success?
      # (true by default)
      attr_accessor :consume_all_input
      alias :consume_all_input? :consume_all_input
      
      # Builds a parser instance
      def initialize
        self.consume_all_input = true
      end

      # 
      # Parses _input_ text and returns a SyntaxNode on success and nil
      # on failure.
      #
      # Recognized options are:
      # [:index] indicates the initial parsing offset in _input_ (Integer).
      # [:rule] indicates a specific parsing rule to launch (Symbol or String). 
      #         Grammar root is used when omitted.
      # [:fail] when true, forces this method to raise a ParseError on parsing
      #         failure instead or returning nil.
      #
      def parse(input, options = {})
        prepare_to_parse(input)
        @index = options[:index] if options[:index]
        rule = options[:rule] || root
        result = send("_nt_#{rule}")
        if (consume_all_input? && index != input.size)
          raise ParseError.new(self)
          nil
        else
          result
        end
      end
      
      # Shortcut for <tt>parse(input, {:rule => rule, :fail => true})</tt>
      def parse_or_fail(input, rule=nil, options={})
        options = options.merge(:rule => rule, :fail => true)
        parse(input, options)
      end

      # Returns the offset in _input_ where the parsing failed.
      def failure_index
        max_terminal_failure_index
      end

      # Returns the line number where the parsing failed.
      def failure_line
        terminal_failures && input.line_of(failure_index)
      end

      # Returns the column number where the parsing failed.
      def failure_column
        terminal_failures && input.column_of(failure_index)
      end

      # Returns a friendly failure message.
      def failure_reason
        return nil unless (tf = terminal_failures) && tf.size > 0
	"Expected " +
	  (tf.size == 1 ?
	   tf[0].expected_string :
           "one of #{tf.map{|f| f.expected_string}.uniq*', '}"
	  ) +
          " at line #{failure_line}, column #{failure_column} (byte #{failure_index+1})" +
          " after #{input[index...failure_index]}"
      end


      protected
      
      # Memoization cache
      attr_reader :node_cache
      
      # Length of the input text.
      attr_reader :input_length
      
      # Write accessor for index
      attr_writer :index
              
      # Prepares all data-structures of the parser before parsing.
      def prepare_to_parse(input)
        @input = input
        @input_length = input.length
        reset_index
        @node_cache = Hash.new {|hash, key| hash[key] = Hash.new}
        @terminal_failures = []
        @regexps = {}
        @max_terminal_failure_index = 0
      end
      
      # Sets the parsing index to 0
      def reset_index
        @index = 0
      end
      
      # Eats the next character, building an instance of <em>node_class</em>
      # and extending it with <em>inline_module</em>. Adds a terminal parse
      # failure if no next character exists.
      def parse_anything(node_class = SyntaxNode, inline_module = nil)
        if index < input.length
          result = instantiate_node(node_class,input, index...(index + 1))
          result.extend(inline_module) if inline_module
          @index += 1
          result
        else
          terminal_parse_failure("any character")
        end
      end
    
      # Instanciates a given <em>node_type</em>. If it seems a class, 
      # calls _new_ on it passing _args_ as arguments. Otherwise consider
      # it as an extension module on a SyntaxNode.
      def instantiate_node(node_type,*args)
        if node_type.respond_to? :new 
          node_type.new(*args)
        else
          SyntaxNode.new(*args).extend(node_type)
        end
      end
    
      # Checks if a terminal can be found at index.
      def has_terminal?(terminal, regex, index)
        rx = @regexps[terminal]
        if rx.nil?
          rx = (regex ? Regexp.new(terminal) : terminal)
          @regexps[terminal] = rx
        end
        if regex
          input.index(rx, index)==index
        else
          0.upto(terminal.length-1) do |i|
            return false unless input[index+i]==terminal[i]
          end
        end
      end
    
      # Fired by parsing rules when a terminal symbol cannot be parsed.
      # This method automatically maintains the terminal_failures array.
      def terminal_parse_failure(expected_string)
        return nil if index < max_terminal_failure_index
        if index > max_terminal_failure_index
          @max_terminal_failure_index = index
          @terminal_failures = []
        end
        terminal_failures << TerminalParseFailure.new(index, expected_string)
        return nil
      end
      
    end
  end
end

module Treetop
  module Runtime
    
    #
    # Node inside parse trees built by Treetop generated parsers.
    #
    # Some invariants and contra-invariants you need to keep in mind:
    # - A terminal? node does never have elements, which is nil.
    # - A nonterminal? always have elements, but it can be an empty array.
    # - An empty? node also implies that no source has been parsed (the interval 
    #   is itself empty), and does never contain elements (nil or empty array).
    # - An empty? node can be terminal or nonterminal (the former typically comes 
    #   from a '' parsing symbol, the second case from star expressions).
    #
    class SyntaxNode
      
      # Complete input text
      attr_reader :input
      
      # Interval of _input_ that led to this node
      attr_reader :interval 
      
      # Children of this node; nil if terminal
      attr_reader :elements
      
      # Parent of this node; nil if root
      attr_accessor :parent

      # Creates a SyntaxNode instance. Children passed in _elements_ are
      # kept informed of their parent.
      def initialize(input, interval, elements = nil)
        @input = input
        @interval = interval
        if @elements = elements
          elements.each do |element|
            element.parent = self
          end
        end
      end

      # True for terminal nodes (nodes created by terminal symbols in the grammar), 
      # false otherwise.
      def terminal?
        @elements.nil?
      end

      # Inverse of terminal?
      def nonterminal?
        !terminal?
      end

      # Returns the text proportion that led to the creation of this node, 
      # i.e. input[interval].
      def text_value
        input[interval]
      end

      # True if no source text underlies this node, false otherwise.
      def empty?
	      interval.first == interval.last && interval.exclude_end?
      end

      # Returns an array with anonymous and declared modules that extend this node.
      # Anonymous modules come from inline module definitions in the grammar as well 
      # as modules automatically generated by Treetop during grammar compilation
      # to handle labels. Declared modules are those explicitly used in <...> 
      # constructs in the grammar definition.
      def extension_modules
        local_extensions =
          class <<self
            included_modules-Object.included_modules
          end
        if local_extensions.size > 0
          local_extensions
        else
          []    # There weren't any; must be a literal node
        end
      end

      # Returns an array with all attribute readers that correspond to labeled
      # children.
      def interesting_methods
        em = extension_modules
        methods-[em.last ? em.last.methods : nil]-self.class.instance_methods
      end

      # Returns a complete tree view of this node and its children.
      def inspect(indent="")
        em = extension_modules
        interesting_methods = self.interesting_methods
        im = interesting_methods.size > 0 ? " (#{interesting_methods.join(",")})" : ""
        tv = text_value
        tv = "...#{tv[-20..-1]}" if tv.size > 20

        indent +
        self.class.to_s.sub(/.*:/,'') +
          em.map{|m| "+"+m.to_s.sub(/.*:/,'')}*"" +
          " offset=#{interval.first}" +
          ", #{tv.inspect}" +
          im + " [#{terminal?}]" +
          (elements && elements.size > 0 ?
            ":" +
              (@elements||[]).map{|e|
          begin
            "\n"+e.inspect(indent+"  ")
          rescue  # Defend against inspect not taking a parameter
            "\n"+indent+" "+e.inspect
          end
              }.join("") :
            ""
          )
      end
      
    end
  end
end

